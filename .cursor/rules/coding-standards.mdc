---
description: Import style and coding conventions - use qualified imports, no 'from X import Y'
globs: "**/*.py"
alwaysApply: true
---
# Coding Standards

## Import Style

**Never import symbols directly into the namespace.** Always use qualified imports.

### The Rule

```python
# ❌ FORBIDDEN - pollutes namespace with imported symbols
from pathlib import Path
from typing import Any, Dict
from brynhild.config import Settings

# ✅ CORRECT - qualified imports
import pathlib as _pathlib       # External: underscore prefix
import typing as _typing         # External: underscore prefix
import brynhild.config as config # Internal: NO underscore

# Then use qualified names
path: _pathlib.Path = _pathlib.Path("/tmp")
data: _typing.Dict[str, _typing.Any] = {}
settings = config.Settings()
```

### Why This Convention

1. **Explicit provenance** - Always clear where a symbol comes from
2. **No namespace pollution** - Module namespace only contains what's defined there
3. **Easier refactoring** - Grep-friendly, easy to find all uses of a module
4. **Avoids shadowing** - Can't accidentally shadow builtins or other names

## External vs Internal Imports

**Key distinction:**
- **External imports** (stdlib, third-party): Use underscore prefix (`_`)
- **Internal imports** (brynhild.*): NO underscore prefix

This makes it immediately clear what's part of our codebase vs external dependencies.

### External: Standard Library

```python
# ✅ CORRECT - underscore prefix for stdlib
import os as _os
import sys as _sys
import json as _json
import pathlib as _pathlib
import typing as _typing
import dataclasses as _dataclasses
import subprocess as _subprocess
import asyncio as _asyncio
import unittest.mock as _mock
from collections import abc as _abc  # Exception: submodule access

# Usage
_pathlib.Path("/tmp")
_typing.Optional[str]
_json.dumps(data)
```

### External: Third-Party Packages

```python
# ✅ CORRECT - underscore prefix for third-party
import click as _click
import pydantic as _pydantic
import httpx as _httpx
import pytest as _pytest

# Usage
@_click.command()
def main() -> None:
    pass

class Config(_pydantic.BaseModel):
    pass
```

### Internal: Brynhild Packages

```python
# ✅ CORRECT - NO underscore for internal brynhild imports
import brynhild.config as config
import brynhild.session as session
import brynhild.cli as cli
import brynhild.cli.main as cli_main

# Usage - clean names for internal code
settings = config.Settings()
sess = session.Session.create()
```

### Why Different Prefixes?

| Import Type | Prefix | Example | Rationale |
|-------------|--------|---------|-----------|
| External (stdlib) | `_` | `_json` | Signals "from outside project" |
| External (third-party) | `_` | `_click` | Signals "from outside project" |
| Internal (brynhild) | none | `config` | Clean names for our own code |

1. **Visual distinction** - Immediately see external vs internal dependencies
2. **Semantic meaning** - Underscore = "imported from outside this project"
3. **Cleaner internal code** - You work with internal modules most, so they get cleaner names

### Exception: `__all__` Exports

In `__init__.py` files that define public APIs, you may import for re-export:

```python
# In brynhild/__init__.py - this is acceptable for public API
from brynhild.config.settings import Settings
from brynhild.session.session import Session

__all__ = ["Settings", "Session"]
```

### Exception: Type Checking Imports

For type annotations that are only used at type-check time:

```python
import typing as _typing

if _typing.TYPE_CHECKING:
    # These are only used for type hints, never at runtime
    import some_heavy_module as _heavy
```

## Complete Example

```python
"""Example module showing proper import style."""

# Standard library - underscore prefix
import json as _json
import pathlib as _pathlib
import typing as _typing

# Third-party - underscore prefix
import click as _click

# Internal brynhild - NO underscore
import brynhild.config as config
import brynhild.session as session


def process_file(path: _pathlib.Path) -> session.Session:
    """Process a file and return a session."""
    settings = config.Settings()
    data = _json.loads(path.read_text())
    return session.Session.create(model=settings.model)
```

## Other Standards

### Type Hints

Always use type hints for function signatures:

```python
def process_data(
    input_path: _pathlib.Path,
    options: _typing.Dict[str, _typing.Any],
) -> _typing.Optional[str]:
    ...
```

### Docstrings

Use Google-style docstrings:

```python
def function(arg1: str, arg2: int) -> bool:
    """Short description.

    Longer description if needed.

    Args:
        arg1: Description of arg1.
        arg2: Description of arg2.

    Returns:
        Description of return value.

    Raises:
        ValueError: When something is wrong.
    """
```
