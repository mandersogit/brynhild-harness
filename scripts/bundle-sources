#!/bin/bash
# -*- mode: python -*-
# vim: set ft=python:
# Polyglot bash/python script - bash delegates to venv python
"true" '''\'
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
exec "$PROJECT_ROOT/local.venv/bin/python" "$0" "$@"
'''

"""
Bundle source files into a markdown document.

Usage:
    bundle-sources -o OUTPUT FILES...
    bundle-sources -o OUTPUT --glob PATTERN
    bundle-sources -o OUTPUT -t TITLE FILES...

Examples:
    # Bundle specific files
    bundle-sources -o workflow/dcm-source.md src/brynhild/utils/deep_chain_map/*.py

    # Bundle with a title
    bundle-sources -o workflow/dcm-tests.md -t "DCM Test Suite" tests/utils/test_dcm*.py

    # Bundle using glob pattern
    bundle-sources -o workflow/all-tools.md --glob "src/brynhild/tools/*.py"

Output Format:
    # {Title}

    ## `{relative/path/to/file.py}`

    ```python
    {file contents}
    ```
"""

import argparse as _argparse
import pathlib as _pathlib
import sys as _sys


def get_language(path: _pathlib.Path) -> str:
    """Determine the language tag for a file based on extension."""
    suffix_map = {
        ".py": "python",
        ".yaml": "yaml",
        ".yml": "yaml",
        ".json": "json",
        ".md": "markdown",
        ".toml": "toml",
        ".sh": "bash",
        ".bash": "bash",
        ".js": "javascript",
        ".ts": "typescript",
        ".sql": "sql",
        ".html": "html",
        ".css": "css",
        ".xml": "xml",
        ".txt": "text",
        ".rst": "rst",
    }
    return suffix_map.get(path.suffix.lower(), "text")


def make_relative_path(path: _pathlib.Path, project_root: _pathlib.Path) -> str:
    """Make a path relative to the project root if possible."""
    try:
        return str(path.relative_to(project_root))
    except ValueError:
        return str(path)


def bundle_files(
    files: list[_pathlib.Path],
    output: _pathlib.Path,
    title: str | None,
    project_root: _pathlib.Path,
) -> None:
    """Bundle source files into a markdown document."""
    lines: list[str] = []

    # Title
    if title:
        lines.append(f"# {title}")
    else:
        # Generate title from output filename
        stem = output.stem.replace("-", " ").replace("_", " ").title()
        lines.append(f"# {stem}")
    lines.append("")

    # Process each file
    for file_path in sorted(files):
        if not file_path.exists():
            print(f"Warning: file not found: {file_path}", file=_sys.stderr)
            continue

        if not file_path.is_file():
            print(f"Warning: not a file: {file_path}", file=_sys.stderr)
            continue

        rel_path = make_relative_path(file_path, project_root)
        language = get_language(file_path)

        try:
            content = file_path.read_text(encoding="utf-8")
        except (OSError, UnicodeDecodeError) as e:
            print(f"Warning: cannot read {file_path}: {e}", file=_sys.stderr)
            continue

        # Remove trailing whitespace from each line, but preserve file structure
        content_lines = content.rstrip().split("\n")
        content = "\n".join(line.rstrip() for line in content_lines)

        lines.append(f"## `{rel_path}`")
        lines.append("")
        lines.append(f"```{language}")
        lines.append(content)
        lines.append("```")
        lines.append("")

    # Write output
    output.parent.mkdir(parents=True, exist_ok=True)
    output.write_text("\n".join(lines), encoding="utf-8")

    print(f"Bundled {len(files)} files -> {output}")


def resolve_files(
    file_args: list[str],
    glob_pattern: str | None,
    project_root: _pathlib.Path,
) -> list[_pathlib.Path]:
    """Resolve file arguments and glob patterns to a list of paths."""
    files: list[_pathlib.Path] = []

    if glob_pattern:
        # Use glob from project root
        files.extend(sorted(project_root.glob(glob_pattern)))
    else:
        for arg in file_args:
            path = _pathlib.Path(arg)
            if not path.is_absolute():
                path = project_root / path

            if "*" in arg or "?" in arg:
                # Treat as glob pattern
                files.extend(sorted(project_root.glob(arg)))
            elif path.is_dir():
                # Add all Python files in directory
                files.extend(sorted(path.glob("*.py")))
            else:
                files.append(path)

    # Deduplicate while preserving order
    seen: set[_pathlib.Path] = set()
    unique: list[_pathlib.Path] = []
    for f in files:
        resolved = f.resolve()
        if resolved not in seen:
            seen.add(resolved)
            unique.append(f)

    return unique


def main() -> int:
    """Main entry point."""
    parser = _argparse.ArgumentParser(
        description="Bundle source files into a markdown document.",
        formatter_class=_argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "-o", "--output",
        type=_pathlib.Path,
        required=True,
        help="Output markdown file path",
    )
    parser.add_argument(
        "-t", "--title",
        type=str,
        default=None,
        help="Document title (default: derived from output filename)",
    )
    parser.add_argument(
        "--glob",
        type=str,
        default=None,
        help="Glob pattern to match files (relative to project root)",
    )
    parser.add_argument(
        "files",
        nargs="*",
        help="Files to bundle (supports glob patterns)",
    )

    args = parser.parse_args()

    # Find project root (parent of scripts/)
    script_path = _pathlib.Path(__file__).resolve()
    project_root = script_path.parent.parent

    # Resolve files
    files = resolve_files(args.files, args.glob, project_root)

    if not files:
        print("Error: no files specified or matched", file=_sys.stderr)
        return 1

    # Make output path absolute if needed
    output = args.output
    if not output.is_absolute():
        output = project_root / output

    bundle_files(files, output, args.title, project_root)
    return 0


if __name__ == "__main__":
    _sys.exit(main())

