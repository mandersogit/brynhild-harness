#!/bin/bash
# -*- mode: python -*-
# vim: set ft=python:
# Polyglot bash/python script - bash delegates to venv python
"true" '''\'
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
exec "$PROJECT_ROOT/local.venv/bin/python" "$0" "$@"
'''

"""
Commit helper for brynhild repositories.

Manages commits across the development repo and public repo via YAML plans.

Usage:
    ./scripts/commit-helper plan.yaml                    # Preview
    ./scripts/commit-helper plan.yaml --execute          # Execute in source repo
    ./scripts/commit-helper plan.yaml --sync-public      # Sync to public repo
"""

import pathlib as _pathlib
import shutil as _shutil
import subprocess as _subprocess
import sys as _sys
import typing as _typing

import click as _click
import yaml as _yaml


# Default repository paths for brynhild
DEFAULT_SOURCE_REPO = _pathlib.Path("/Users/manderso/git/github/brynhild")
DEFAULT_PUBLIC_REPO = _pathlib.Path("/Users/manderso/git/github/brynhild-public")


def _run_git(
    args: list[str],
    cwd: _pathlib.Path,
    dry_run: bool = False,
) -> _subprocess.CompletedProcess[str]:
    """Run a git command."""
    cmd = ["git"] + args
    if dry_run:
        _click.echo(f"  [DRY-RUN] {' '.join(cmd)}")
        return _subprocess.CompletedProcess(cmd, 0, "", "")

    result = _subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        _click.echo(f"  ERROR: git {' '.join(args)}", err=True)
        _click.echo(f"  {result.stderr}", err=True)
        _sys.exit(1)
    return result


def _validate_files(
    files: list[str],
    repo_path: _pathlib.Path,
) -> list[str]:
    """Validate that all files exist. Returns list of missing files."""
    missing = []
    for f in files:
        path = repo_path / f
        if not path.exists():
            missing.append(f)
    return missing


def _find_duplicate_files(
    commits: list[dict[str, _typing.Any]],
) -> dict[str, list[int]]:
    """Find files that appear in multiple commits.
    
    Returns dict mapping filename to list of commit indices (1-based).
    """
    file_commits: dict[str, list[int]] = {}
    for i, commit in enumerate(commits, 1):
        for f in commit.get("files", []):
            if f not in file_commits:
                file_commits[f] = []
            file_commits[f].append(i)
    
    # Return only duplicates
    return {f: commits for f, commits in file_commits.items() if len(commits) > 1}


def _load_plan(plan_path: _pathlib.Path) -> dict[str, _typing.Any]:
    """Load commit plan from YAML file."""
    with plan_path.open() as f:
        return _yaml.safe_load(f)


def _get_repo_paths(
    plan: dict[str, _typing.Any],
) -> tuple[_pathlib.Path, _pathlib.Path]:
    """Get source and public repo paths from plan or defaults."""
    src = _pathlib.Path(plan.get("source_repo", DEFAULT_SOURCE_REPO))
    dst = _pathlib.Path(plan.get("public_repo", DEFAULT_PUBLIC_REPO))
    return src, dst


@_click.group(invoke_without_command=True)
@_click.argument("plan_file", type=_click.Path(exists=True, path_type=_pathlib.Path))
@_click.pass_context
def cli(ctx: _click.Context, plan_file: _pathlib.Path) -> None:
    """
    Commit helper for brynhild repositories.

    Manages commits across development and public repos via YAML plans.

    \b
    By default (no subcommand), shows a preview of the plan.
    Use subcommands to execute or sync.

    \b
    Examples:
        ./scripts/commit-helper plan.yaml                    # Preview
        ./scripts/commit-helper plan.yaml execute            # Execute commits
        ./scripts/commit-helper plan.yaml execute --dry-run  # Show what execute would do
        ./scripts/commit-helper plan.yaml sync-public        # Sync to public repo
    """
    ctx.ensure_object(dict)
    ctx.obj["plan_file"] = plan_file

    # If no subcommand, show preview
    if ctx.invoked_subcommand is None:
        _preview(plan_file)


def _preview(plan_path: _pathlib.Path) -> None:
    """Show what would happen without executing."""
    plan = _load_plan(plan_path)
    src_repo, dst_repo = _get_repo_paths(plan)

    _click.echo(f"=== Commit Plan: {plan_path.name} ===")
    _click.echo(f"Source repo: {src_repo}")
    _click.echo(f"Public repo: {dst_repo}")
    _click.echo(f"Commits: {len(plan.get('commits', []))}")
    _click.echo()

    commits = plan.get("commits", [])

    # Check for duplicate files (same file in multiple commits)
    duplicates = _find_duplicate_files(commits)
    if duplicates:
        _click.echo("ERROR: Files appear in multiple commits:", err=True)
        _click.echo("(Each file can only be in ONE commit - hunking not supported)", err=True)
        for f, commit_nums in sorted(duplicates.items()):
            _click.echo(f"  - {f} → commits {commit_nums}", err=True)
        _sys.exit(1)

    # Validate all files exist
    all_files: set[str] = set()
    for commit in commits:
        all_files.update(commit.get("files", []))

    missing = _validate_files(list(all_files), src_repo)
    if missing:
        _click.echo("ERROR: Missing files in source repo:", err=True)
        for f in missing:
            _click.echo(f"  - {f}", err=True)
        _sys.exit(1)

    _click.echo(_click.style(f"✓ All {len(all_files)} files exist in source repo", fg="green"))
    _click.echo()

    # Show each commit
    for i, commit in enumerate(plan.get("commits", []), 1):
        msg_lines = commit["message"].strip().split("\n")
        title = msg_lines[0]
        files = commit.get("files", [])

        _click.echo(f"--- Commit {i}: {title} ---")
        _click.echo(f"Files ({len(files)}):")
        for f in files[:5]:
            _click.echo(f"  + {f}")
        if len(files) > 5:
            _click.echo(f"  ... and {len(files) - 5} more")
        _click.echo()


@cli.command()
@_click.option(
    "--dry-run", "-n",
    is_flag=True,
    help="Show what would happen without committing",
)
@_click.pass_context
def execute(ctx: _click.Context, dry_run: bool) -> None:
    """Execute commits in the source (development) repository."""
    plan_path: _pathlib.Path = ctx.obj["plan_file"]
    plan = _load_plan(plan_path)
    src_repo, _ = _get_repo_paths(plan)

    _click.echo(f"=== Executing commits in {src_repo} ===")
    if dry_run:
        _click.echo("(DRY RUN - no changes will be made)")
    _click.echo()

    # Validate all files exist
    all_files: set[str] = set()
    for commit in plan.get("commits", []):
        all_files.update(commit.get("files", []))

    missing = _validate_files(list(all_files), src_repo)
    if missing:
        _click.echo("ERROR: Missing files:", err=True)
        for f in missing:
            _click.echo(f"  - {f}", err=True)
        _sys.exit(1)

    # Execute each commit
    # TODO: Fix pre-staged files issue. If files are already staged before
    # running execute, they all get committed in the first commit because
    # `git commit` commits ALL staged changes, not just files staged in this
    # iteration. Fix: add `_run_git(["reset", "HEAD"], src_repo, dry_run)`
    # before the staging loop to unstage everything first.
    # See: workflow/task-commit-helper-fix.md
    for i, commit in enumerate(plan.get("commits", []), 1):
        msg = commit["message"].strip()
        files = commit.get("files", [])
        title = msg.split("\n")[0]

        _click.echo(f">>> Commit {i}: {title}")

        # Stage files
        for f in files:
            _run_git(["add", f], src_repo, dry_run)

        # Check if there are staged changes
        if not dry_run:
            result = _subprocess.run(
                ["git", "diff", "--cached", "--quiet"],
                cwd=src_repo,
            )
            if result.returncode == 0:
                _click.echo("  (no changes to commit, skipping)")
                continue

        # Commit
        _run_git(["commit", "-m", msg], src_repo, dry_run)
        _click.echo()

    _click.echo("=== Done ===")
    if not dry_run:
        commit_count = len(plan.get("commits", []))
        _run_git(["log", "--oneline", f"-{commit_count}"], src_repo, dry_run)


@cli.command("sync-public")
@_click.option(
    "--dry-run", "-n",
    is_flag=True,
    help="Show what would happen without committing",
)
@_click.pass_context
def sync_public(ctx: _click.Context, dry_run: bool) -> None:
    """Copy files and create matching commits in the public repository."""
    plan_path: _pathlib.Path = ctx.obj["plan_file"]
    plan = _load_plan(plan_path)
    src_repo, dst_repo = _get_repo_paths(plan)

    _click.echo(f"=== Syncing to {dst_repo} ===")
    if dry_run:
        _click.echo("(DRY RUN - no changes will be made)")
    _click.echo()

    if not dst_repo.exists():
        _click.echo(f"ERROR: Public repo not found: {dst_repo}", err=True)
        _sys.exit(1)

    # Execute each commit
    for i, commit in enumerate(plan.get("commits", []), 1):
        msg = commit["message"].strip()
        files = commit.get("files", [])
        title = msg.split("\n")[0]

        _click.echo(f">>> Commit {i}: {title}")

        # Copy files
        for f in files:
            src_path = src_repo / f
            dst_path = dst_repo / f

            if not src_path.exists():
                _click.echo(f"  WARNING: Source file missing: {f}")
                continue

            # Create parent directories
            if not dry_run:
                dst_path.parent.mkdir(parents=True, exist_ok=True)
                _shutil.copy2(src_path, dst_path)
            _click.echo(f"  [COPY] {f}")

        # Stage all changes
        _run_git(["add", "-A"], dst_repo, dry_run)

        # Check if there are staged changes
        if not dry_run:
            result = _subprocess.run(
                ["git", "diff", "--cached", "--quiet"],
                cwd=dst_repo,
            )
            if result.returncode == 0:
                _click.echo("  (no changes to commit, skipping)")
                continue

        # Commit
        _run_git(["commit", "-m", msg], dst_repo, dry_run)
        _click.echo()

    _click.echo("=== Done ===")
    if not dry_run:
        commit_count = len(plan.get("commits", []))
        _run_git(["log", "--oneline", f"-{commit_count}"], dst_repo, dry_run)


if __name__ == "__main__":
    cli()
