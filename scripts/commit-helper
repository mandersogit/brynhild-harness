#!/bin/bash
# -*- mode: python -*-
# vim: set ft=python:
# Polyglot bash/python script - bash delegates to venv python
"true" '''\'
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
exec "$PROJECT_ROOT/local.venv/bin/python" "$0" "$@"
'''

"""
Commit helper for brynhild repositories.

Manages commits across the development repo and public repo via YAML plans.

Usage:
    ./scripts/commit-helper plan.yaml                    # Preview
    ./scripts/commit-helper plan.yaml --execute          # Execute in source repo
    ./scripts/commit-helper plan.yaml --sync-public      # Sync to public repo

Commit Plan Format:
    commits:
      - message: |
          type: short description
        files:
          - path/to/added_or_modified.py
        deleted:
          - path/to/removed.py
"""

# ruff: noqa: E402 (imports not at top - polyglot script)

import pathlib as _pathlib
import shutil as _shutil
import subprocess as _subprocess
import sys as _sys
import typing as _typing

import click as _click
import yaml as _yaml

# Default repository paths for brynhild
DEFAULT_SOURCE_REPO = _pathlib.Path("/Users/manderso/git/github/brynhild")
DEFAULT_PUBLIC_REPO = _pathlib.Path("/Users/manderso/git/github/brynhild-public")

# TODO: Add branch validation for dual-repo workflow
# The sync-public command should verify that both the source (private) repo and
# the public repo are on the same branch before allowing commits. Currently,
# if the repos are on different branches, commits will silently go to whatever
# branch each repo happens to be on, which can cause history divergence.
#
# Suggested fix:
# 1. In sync-public, get current branch of both repos via `git branch --show-current`
# 2. If branches differ, abort with clear error message
# 3. Consider also checking for uncommitted changes in the public repo


def _run_git(
    args: list[str],
    cwd: _pathlib.Path,
    dry_run: bool = False,
    check: bool = True,
) -> _subprocess.CompletedProcess[str]:
    """Run a git command.

    Args:
        args: Git command arguments (without 'git' prefix).
        cwd: Working directory for the command.
        dry_run: If True, print command without executing.
        check: If True, exit on non-zero return code.

    Returns:
        CompletedProcess result.
    """
    cmd = ["git"] + args
    if dry_run:
        _click.echo(f"  [DRY-RUN] {' '.join(cmd)}")
        return _subprocess.CompletedProcess(cmd, 0, "", "")

    result = _subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
    )
    if check and result.returncode != 0:
        _click.echo(f"  ERROR: git {' '.join(args)}", err=True)
        _click.echo(f"  {result.stderr}", err=True)
        _sys.exit(1)
    return result


def _validate_files_exist(
    files: list[str],
    repo_path: _pathlib.Path,
) -> list[str]:
    """Validate that all files exist on disk.

    Returns list of missing files.
    """
    missing = []
    for f in files:
        path = repo_path / f
        if not path.exists():
            missing.append(f)
    return missing


def _validate_deleted_files(
    files: list[str],
    repo_path: _pathlib.Path,
) -> tuple[list[str], list[str]]:
    """Validate deleted files: should be tracked by git but not exist on disk.

    Returns:
        Tuple of (still_exist, not_tracked) - files that fail validation.
    """
    still_exist = []
    not_tracked = []

    for f in files:
        path = repo_path / f
        if path.exists():
            still_exist.append(f)
            continue

        # Check if file is tracked by git (was deleted)
        result = _subprocess.run(
            ["git", "ls-files", "--deleted", f],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )
        if not result.stdout.strip():
            # Not in deleted list, check if it's in the index at all
            result2 = _subprocess.run(
                ["git", "ls-files", f],
                cwd=repo_path,
                capture_output=True,
                text=True,
            )
            if not result2.stdout.strip():
                not_tracked.append(f)

    return still_exist, not_tracked


def _find_duplicate_files(
    commits: list[dict[str, _typing.Any]],
) -> dict[str, list[int]]:
    """Find files that appear in multiple commits.

    Checks both 'files' and 'deleted' lists.

    Returns dict mapping filename to list of commit indices (1-based).
    """
    file_commits: dict[str, list[int]] = {}
    for i, commit in enumerate(commits, 1):
        # Check regular files
        for f in commit.get("files", []):
            if f not in file_commits:
                file_commits[f] = []
            file_commits[f].append(i)
        # Check deleted files
        for f in commit.get("deleted", []):
            if f not in file_commits:
                file_commits[f] = []
            file_commits[f].append(i)

    # Return only duplicates
    return {f: commits for f, commits in file_commits.items() if len(commits) > 1}


def _load_plan(plan_path: _pathlib.Path) -> dict[str, _typing.Any]:
    """Load commit plan from YAML file."""
    with plan_path.open() as f:
        return _yaml.safe_load(f)


def _get_repo_paths(
    plan: dict[str, _typing.Any],
) -> tuple[_pathlib.Path, _pathlib.Path]:
    """Get source and public repo paths from plan or defaults."""
    src = _pathlib.Path(plan.get("source_repo", DEFAULT_SOURCE_REPO))
    dst = _pathlib.Path(plan.get("public_repo", DEFAULT_PUBLIC_REPO))
    return src, dst


@_click.group(invoke_without_command=True)
@_click.argument("plan_file", type=_click.Path(exists=True, path_type=_pathlib.Path))
@_click.pass_context
def cli(ctx: _click.Context, plan_file: _pathlib.Path) -> None:
    """
    Commit helper for brynhild repositories.

    Manages commits across development and public repos via YAML plans.

    \b
    By default (no subcommand), shows a preview of the plan.
    Use subcommands to execute or sync.

    \b
    Examples:
        ./scripts/commit-helper plan.yaml                    # Preview
        ./scripts/commit-helper plan.yaml execute            # Execute commits
        ./scripts/commit-helper plan.yaml execute --dry-run  # Show what execute would do
        ./scripts/commit-helper plan.yaml sync-public        # Sync to public repo
    """
    ctx.ensure_object(dict)
    ctx.obj["plan_file"] = plan_file

    # If no subcommand, show preview
    if ctx.invoked_subcommand is None:
        _preview(plan_file)


def _preview(plan_path: _pathlib.Path) -> None:
    """Show what would happen without executing."""
    plan = _load_plan(plan_path)
    src_repo, dst_repo = _get_repo_paths(plan)

    _click.echo(f"=== Commit Plan: {plan_path.name} ===")
    _click.echo(f"Source repo: {src_repo}")
    _click.echo(f"Public repo: {dst_repo}")
    _click.echo(f"Commits: {len(plan.get('commits', []))}")
    _click.echo()

    commits = plan.get("commits", [])

    # Check for duplicate files (same file in multiple commits)
    duplicates = _find_duplicate_files(commits)
    if duplicates:
        _click.echo("ERROR: Files appear in multiple commits:", err=True)
        _click.echo("(Each file can only be in ONE commit - hunking not supported)", err=True)
        for f, commit_nums in sorted(duplicates.items()):
            _click.echo(f"  - {f} → commits {commit_nums}", err=True)
        _sys.exit(1)

    # Collect all files and deleted files
    all_files: set[str] = set()
    all_deleted: set[str] = set()
    for commit in commits:
        all_files.update(commit.get("files", []))
        all_deleted.update(commit.get("deleted", []))

    # Validate files exist
    has_errors = False
    if all_files:
        missing = _validate_files_exist(list(all_files), src_repo)
        if missing:
            _click.echo("ERROR: Missing files in source repo:", err=True)
            for f in missing:
                _click.echo(f"  - {f}", err=True)
            has_errors = True
        else:
            _click.echo(
                _click.style(f"✓ All {len(all_files)} files exist", fg="green")
            )

    # Validate deleted files
    if all_deleted:
        still_exist, not_tracked = _validate_deleted_files(list(all_deleted), src_repo)
        if still_exist:
            _click.echo("ERROR: Files marked for deletion still exist:", err=True)
            for f in still_exist:
                _click.echo(f"  - {f}", err=True)
            has_errors = True
        if not_tracked:
            _click.echo("ERROR: Deleted files not tracked by git:", err=True)
            for f in not_tracked:
                _click.echo(f"  - {f}", err=True)
            has_errors = True
        if not still_exist and not not_tracked:
            _click.echo(
                _click.style(f"✓ All {len(all_deleted)} deletions valid", fg="green")
            )

    if has_errors:
        _sys.exit(1)

    _click.echo()

    # Show each commit
    for i, commit in enumerate(plan.get("commits", []), 1):
        msg_lines = commit["message"].strip().split("\n")
        title = msg_lines[0]
        files = commit.get("files", [])
        deleted = commit.get("deleted", [])

        _click.echo(f"--- Commit {i}: {title} ---")

        # Show added/modified files
        if files:
            _click.echo(f"Files ({len(files)}):")
            for f in files[:5]:
                _click.echo(f"  + {f}")
            if len(files) > 5:
                _click.echo(f"  ... and {len(files) - 5} more")

        # Show deleted files
        if deleted:
            _click.echo(f"Deleted ({len(deleted)}):")
            for f in deleted[:5]:
                _click.echo(_click.style(f"  - {f}", fg="red"))
            if len(deleted) > 5:
                _click.echo(f"  ... and {len(deleted) - 5} more")

        _click.echo()


@cli.command()
@_click.option(
    "--dry-run", "-n",
    is_flag=True,
    help="Show what would happen without committing",
)
@_click.pass_context
def execute(ctx: _click.Context, dry_run: bool) -> None:
    """Execute commits in the source (development) repository."""
    plan_path: _pathlib.Path = ctx.obj["plan_file"]
    plan = _load_plan(plan_path)
    src_repo, _ = _get_repo_paths(plan)

    _click.echo(f"=== Executing commits in {src_repo} ===")
    if dry_run:
        _click.echo("(DRY RUN - no changes will be made)")
    _click.echo()

    # Collect and validate all files
    all_files: set[str] = set()
    all_deleted: set[str] = set()
    for commit in plan.get("commits", []):
        all_files.update(commit.get("files", []))
        all_deleted.update(commit.get("deleted", []))

    # Validate files exist
    if all_files:
        missing = _validate_files_exist(list(all_files), src_repo)
        if missing:
            _click.echo("ERROR: Missing files:", err=True)
            for f in missing:
                _click.echo(f"  - {f}", err=True)
            _sys.exit(1)

    # Validate deleted files
    if all_deleted:
        still_exist, not_tracked = _validate_deleted_files(list(all_deleted), src_repo)
        if still_exist:
            _click.echo("ERROR: Files marked for deletion still exist:", err=True)
            for f in still_exist:
                _click.echo(f"  - {f}", err=True)
            _sys.exit(1)
        if not_tracked:
            _click.echo("ERROR: Deleted files not tracked by git:", err=True)
            for f in not_tracked:
                _click.echo(f"  - {f}", err=True)
            _sys.exit(1)

    # Execute each commit
    # TODO: Fix pre-staged files issue. If files are already staged before
    # running execute, they all get committed in the first commit because
    # `git commit` commits ALL staged changes, not just files staged in this
    # iteration. Fix: add `_run_git(["reset", "HEAD"], src_repo, dry_run)`
    # before the staging loop to unstage everything first.
    # See: workflow/task-commit-helper-fix.md
    for i, commit in enumerate(plan.get("commits", []), 1):
        msg = commit["message"].strip()
        files = commit.get("files", [])
        deleted = commit.get("deleted", [])
        title = msg.split("\n")[0]

        _click.echo(f">>> Commit {i}: {title}")

        # Stage added/modified files
        for f in files:
            _run_git(["add", f], src_repo, dry_run)

        # Stage deleted files
        for f in deleted:
            _run_git(["rm", "--cached", f], src_repo, dry_run)

        # Check if there are staged changes
        if not dry_run:
            result = _subprocess.run(
                ["git", "diff", "--cached", "--quiet"],
                cwd=src_repo,
            )
            if result.returncode == 0:
                _click.echo("  (no changes to commit, skipping)")
                continue

        # Commit
        _run_git(["commit", "-m", msg], src_repo, dry_run)
        _click.echo()

    _click.echo("=== Done ===")
    if not dry_run:
        commit_count = len(plan.get("commits", []))
        _run_git(["log", "--oneline", f"-{commit_count}"], src_repo, dry_run)


@cli.command("sync-public")
@_click.option(
    "--dry-run", "-n",
    is_flag=True,
    help="Show what would happen without committing",
)
@_click.pass_context
def sync_public(ctx: _click.Context, dry_run: bool) -> None:
    """Copy files and create matching commits in the public repository."""
    plan_path: _pathlib.Path = ctx.obj["plan_file"]
    plan = _load_plan(plan_path)
    src_repo, dst_repo = _get_repo_paths(plan)

    _click.echo(f"=== Syncing to {dst_repo} ===")
    if dry_run:
        _click.echo("(DRY RUN - no changes will be made)")
    _click.echo()

    if not dst_repo.exists():
        _click.echo(f"ERROR: Public repo not found: {dst_repo}", err=True)
        _sys.exit(1)

    # Execute each commit
    for i, commit in enumerate(plan.get("commits", []), 1):
        msg = commit["message"].strip()
        files = commit.get("files", [])
        deleted = commit.get("deleted", [])
        title = msg.split("\n")[0]

        _click.echo(f">>> Commit {i}: {title}")

        # Copy added/modified files
        for f in files:
            src_path = src_repo / f
            dst_path = dst_repo / f

            if not src_path.exists():
                _click.echo(f"  WARNING: Source file missing: {f}")
                continue

            # Create parent directories
            if not dry_run:
                dst_path.parent.mkdir(parents=True, exist_ok=True)
                _shutil.copy2(src_path, dst_path)
            _click.echo(f"  [COPY] {f}")

        # Delete files
        for f in deleted:
            dst_path = dst_repo / f
            if dst_path.exists():
                if not dry_run:
                    dst_path.unlink()
                _click.echo(_click.style(f"  [DELETE] {f}", fg="red"))
            else:
                # File might not exist in public repo yet, that's OK
                _click.echo(f"  [DELETE] {f} (already absent)")

        # Stage all changes
        _run_git(["add", "-A"], dst_repo, dry_run)

        # Check if there are staged changes
        if not dry_run:
            result = _subprocess.run(
                ["git", "diff", "--cached", "--quiet"],
                cwd=dst_repo,
            )
            if result.returncode == 0:
                _click.echo("  (no changes to commit, skipping)")
                continue

        # Commit
        _run_git(["commit", "-m", msg], dst_repo, dry_run)
        _click.echo()

    _click.echo("=== Done ===")
    if not dry_run:
        commit_count = len(plan.get("commits", []))
        _run_git(["log", "--oneline", f"-{commit_count}"], dst_repo, dry_run)


if __name__ == "__main__":
    cli()
